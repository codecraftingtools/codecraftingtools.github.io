

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Design &mdash; Code Craftsmen  documentation</title>
  

  
  
  
  

  

  
  
    

  

  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Software" href="software.html" />
    <link rel="prev" title="Philosophy" href="philosophy.html" /> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> Code Craftsmen
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="vision.html">Vision</a></li>
<li class="toctree-l1"><a class="reference internal" href="status.html">Status</a></li>
<li class="toctree-l1"><a class="reference internal" href="philosophy.html">Philosophy</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Design</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#goals">Goals</a></li>
<li class="toctree-l2"><a class="reference internal" href="#principles">Principles</a></li>
<li class="toctree-l2"><a class="reference internal" href="#considerations">Considerations</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#application-domains">Application Domains</a></li>
<li class="toctree-l3"><a class="reference internal" href="#application-structure">Application Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#hardware-architectures">Hardware Architectures</a></li>
<li class="toctree-l3"><a class="reference internal" href="#operating-systems">Operating Systems</a></li>
<li class="toctree-l3"><a class="reference internal" href="#concurrent-and-parallel-processing">Concurrent and Parallel Processing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#programming-language-support">Programming Language Support</a></li>
<li class="toctree-l3"><a class="reference internal" href="#inter-component-communication-methodology">Inter-Component Communication Methodology</a></li>
<li class="toctree-l3"><a class="reference internal" href="#standardized-component-interfaces">Standardized Component Interfaces</a></li>
<li class="toctree-l3"><a class="reference internal" href="#initialization-and-reset">Initialization and Reset</a></li>
<li class="toctree-l3"><a class="reference internal" href="#configuration">Configuration</a></li>
<li class="toctree-l3"><a class="reference internal" href="#logging-and-screen-output">Logging and Screen Output</a></li>
<li class="toctree-l3"><a class="reference internal" href="#timekeeping">Timekeeping</a></li>
<li class="toctree-l3"><a class="reference internal" href="#scheduling">Scheduling</a></li>
<li class="toctree-l3"><a class="reference internal" href="#blocking-vs-non-blocking-operations">Blocking vs. Non-Blocking Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#file-i-o">File I/O</a></li>
<li class="toctree-l3"><a class="reference internal" href="#data-recording-and-playback">Data Recording and Playback</a></li>
<li class="toctree-l3"><a class="reference internal" href="#top-level-application-code">Top-Level Application Code</a></li>
<li class="toctree-l3"><a class="reference internal" href="#automatic-code-generation">Automatic Code Generation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#file-formats">File Formats</a></li>
<li class="toctree-l3"><a class="reference internal" href="#graphical-design-tools">Graphical Design Tools</a></li>
<li class="toctree-l3"><a class="reference internal" href="#software-stack-for-application-development">Software Stack for Application Development</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="software.html">Software</a></li>
<li class="toctree-l1"><a class="reference internal" href="workflow.html">Workflow</a></li>
<li class="toctree-l1"><a class="reference internal" href="foundation.html">Foundation</a></li>
<li class="toctree-l1"><a class="reference internal" href="notes.html">Notes</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Code Craftsmen</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>Design</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/design.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="design">
<span id="id1"></span><h1>Design<a class="headerlink" href="#design" title="Permalink to this headline">¶</a></h1>
<div class="section" id="goals">
<h2>Goals<a class="headerlink" href="#goals" title="Permalink to this headline">¶</a></h2>
<p>In the Code Craftsmen’s view, writing software is currently much more
difficult than it needs to be.  Our hope, and our primary goal, is to
<strong>restore the joy in programming</strong> by developing code crafting tools
that make software:</p>
<ul class="simple">
<li>Easier to read</li>
<li>Easier to write</li>
<li>Easier to maintain</li>
<li>Easier to reuse</li>
</ul>
</div>
<div class="section" id="principles">
<span id="design-principles"></span><h2>Principles<a class="headerlink" href="#principles" title="Permalink to this headline">¶</a></h2>
<p>There are a few key principles that support these goals and drive our
design strategy, such as:</p>
<ul class="simple">
<li><a class="reference external" href="https://en.wikipedia.org/wiki/Don%27t_repeat_yourself">Don’t repeat yourself</a></li>
<li>Design for testability</li>
<li>Documentation is important</li>
<li>Don’t repeat yourself (unless it’s worth saying twice)</li>
</ul>
<p>Although there are surely some other principles worth adding to this
list, the ones listed here play a major role in many of our design
decisions.</p>
</div>
<div class="section" id="considerations">
<h2>Considerations<a class="headerlink" href="#considerations" title="Permalink to this headline">¶</a></h2>
<p>In this section, we will briefly walk through a number of design
considerations that influence the development of our code crafting
tools.</p>
<div class="section" id="application-domains">
<h3>Application Domains<a class="headerlink" href="#application-domains" title="Permalink to this headline">¶</a></h3>
<p>Our tools support the development of software for a wide variety of
application domains, including, but not limited to:</p>
<ul class="simple">
<li>Embedded systems</li>
<li>Hard and soft real-time systems</li>
<li>Open and closed-loop control systems</li>
<li>Hardware testing</li>
<li>Data acquisition</li>
<li>Simulation</li>
<li>Data processing</li>
<li>Data display</li>
<li>Desktop applications</li>
</ul>
<p>Obviously, the code development cycle for some of these domains
(e.g. embedded, real-time, and closed-loop systems) is much more
cumbersome than for others (e.g. non-real-time simulation).  Because
of this, it is advantageous to develop and <strong>test as much code as
possible in the simplified domains</strong> before moving into the more
complex ones.</p>
</div>
<div class="section" id="application-structure">
<h3>Application Structure<a class="headerlink" href="#application-structure" title="Permalink to this headline">¶</a></h3>
<p>In order to maximize both our productivity and the quality of our
software, our tools facilitate the development of code that can be
used (and reused) in a wide variety of application domains without
alteration.  The following application structure helps us achieve this
goal by <strong>separating the domain-independent code from the
domain-specific code</strong>:</p>
<dl class="docutils">
<dt>Components</dt>
<dd>Well-defined software blocks which can, ideally, be used in a
variety of application domains without alteration.  Components
communicate with other components and interact with their
environment through a standardized, domain-independent interface.
It is important to note that when the Code Craftsmen use the term
<em>component</em>, it is rarely in the general sense, but almost always
refers a software block that conforms to a very specific interface.</dd>
<dt>Run-Time Environment</dt>
<dd>Provides components with a standardized interface to run-time
functionality, such as inter-component communication, scheduling,
timing, and logging.  The underlying implementation may be
general-purpose or tailored to a specific application domain or
operating system.</dd>
<dt>Hierarchic Design</dt>
<dd>Multiple components can be instantiated and their inputs and outputs
connected together in the context of a specific run-time environment
to construct higher-level components and applications.</dd>
<dt>Application Executive</dt>
<dd>Common application-level functionality, such as command-line option
and input file processing, component configuration and
initialization, and application termination may be handled by a
generalized or domain-specific application executive.</dd>
<dt>Hardware and Operating System Abstraction Layer</dt>
<dd>Provides a uniform, hardware-independent programming interface to
standard operating system functionality.</dd>
<dt>Utility Libraries</dt>
<dd>Traditional procedural routines or object-oriented class libraries
may be used within the implementation of a particular component,
run-time environment, or application executive, but do not factor
into the interface between these code segments.</dd>
</dl>
<div class="figure" id="id2">
<img alt="_images/conceptual_run_time_sw_stack.svg" src="_images/conceptual_run_time_sw_stack.svg" /><p class="caption"><span class="caption-text">Run-Time Software Stack (Conceptual)</span></p>
</div>
</div>
<div class="section" id="hardware-architectures">
<h3>Hardware Architectures<a class="headerlink" href="#hardware-architectures" title="Permalink to this headline">¶</a></h3>
<p>Although there are significant differences between some of the
relevant hardware platfoms, our tools enable developers to design
software components that can be deployed on any supported hardware
architecture without source code changes, regardless of the target
instruction set, byte order, or bit width.  This means that any
platform-specific code must be incorporated into a lower-level
abstraction layer, handled by the run-time environment, or
strategically isolated in a few components with abstracted interfaces.
Although we desire to support a broad range of hardware architectures,
the current priority is support for <strong>64-bit x86</strong> and <strong>32-bit ARM</strong>
systems.</p>
</div>
<div class="section" id="operating-systems">
<h3>Operating Systems<a class="headerlink" href="#operating-systems" title="Permalink to this headline">¶</a></h3>
<p>The write-once, run-anywhere philosophy of our tool set also extends
to operating systems, providing a way to develop software components
that are not tied to a particular host OS, but are instead portable to
any supported real-time or non-real-time operating environment without
modification.  In order to achieve this, any OS-specific code must be
incorporated into a lower-level abstraction layer or handled by the
run-time environment.  Although future possibilities are endless, the
current focus is on providing support for:</p>
<ul class="simple">
<li>Standard desktop and embedded Linux</li>
<li>Real-time Linux (PREEMPT_RT)</li>
<li>Real-time Linux (Xenomai/cobalt)</li>
<li>RTEMS</li>
</ul>
</div>
<div class="section" id="concurrent-and-parallel-processing">
<h3>Concurrent and Parallel Processing<a class="headerlink" href="#concurrent-and-parallel-processing" title="Permalink to this headline">¶</a></h3>
<p>Many of our application domains require support for independent
software components executing concurrently, or even simultaneously (in
parallel).  There are several categories of concurrency that we must
consider:</p>
<dl class="docutils">
<dt>Preemptive Multitasking</dt>
<dd>Execution of a task may be forcibly suspended by the operating
system in order to give another task a turn.  Many real-time
systems, for example, have long-running lower-priority tasks that
must be preempted by high-priority short-duration tasks in order to
meet real-time deadlines.  This is typically achieved by creating a
separate operating-system thread or process for each task.  In many
real-time systems, these threads and processes can be assigned
priority values to ensure that high-priority tasks take precedence
over low-priority ones.</dd>
<dt>Cooperative Multitasking</dt>
<dd>Tasks may voluntarily yield execution to other tasks at specific
points in time.  One example of this type of concurrency is a
physics simulation involving several models, where each of these
models must be updated at each time step.</dd>
<dt>Parallel Processing</dt>
<dd>Tasks execute simultaneously on different processors.  Parallel
processing is often used to speed up program execution or perform
several unrelated tasks at once.  In many general-purpose
parallel-processing systems, several operating-system threads or
processes can be executed in parallel.</dd>
</dl>
<p>Our code crafting tools are designed to allow software components to
<strong>execute concurrently</strong> in all of these environments with minimal
effort.  This is critical for real-time applications, but is also
useful for speeding up non-real-time applications by breaking up
software into independent pieces that can run in parallel on separate
processors.  Most software components should not need to know anything
about threads, processes, scheduling policies, or priorities.  Our
tools allow these details to be easily specified when low-level
components are instantiated and combined together into a higher-level
component or application in the context of a run-time environment.</p>
</div>
<div class="section" id="programming-language-support">
<h3>Programming Language Support<a class="headerlink" href="#programming-language-support" title="Permalink to this headline">¶</a></h3>
<p>At a fundamental level, we require all software components to interact
with their run-time environment via a standardized programming
interface based on C function calls.  Our tools provide a set of
higher-level language-specific bindings, built on top of this C API,
that allow components to be implemented in a way that conforms to the
conventions of each programming language.  This approach allows
software components written in various programming languages to
interoperate with one another in the same run-time environment.  Our
current priority is the development of bindings for <strong>C++</strong> and
<strong>Python</strong>, but we hope to eventually support a host of other
programming languages.</p>
</div>
<div class="section" id="inter-component-communication-methodology">
<h3>Inter-Component Communication Methodology<a class="headerlink" href="#inter-component-communication-methodology" title="Permalink to this headline">¶</a></h3>
<p>For the many reasons described elsewhere in this documentation, our
design approach requires components to communicate with one another in
a standardized way.  There are many mechanisms that could be used to
transfer data between components, each with their own advantages and
disadvantages:</p>
<dl class="docutils">
<dt>Method Calls</dt>
<dd><p class="first">In object-oriented programming languages, data is typically
transferred between objects by having one object pass data to (or
receive data from) another object using method calls (member
functions).  This approach is simple and well understood, but has
many drawbacks:</p>
<ul class="last simple">
<li>Passing data between objects using method calls is not
thread-safe, so data transfer between objects in different threads
typically requires manual, error-prone synchronization.</li>
<li>Objects typically have no way to “send out” information.
Typically, the outputs of an object must be retrieved by a
higher-level object.</li>
<li>Custom top-level glue code must often be written to extract data from
one component and pass it into another.</li>
<li>In languages with strict typing, it is difficult to “connect” objects
that were not designed specifically to work together.</li>
<li>Inter-language operation is usually possible, but tedious to
implement.</li>
</ul>
</dd>
<dt>Callback Functions</dt>
<dd><p class="first">In some object-oriented architectures, objects do attempt to “send
out” data by storing a pointer to an output object and calling a
member-function of that object to send data to that object.  This
approach still has many issues:</p>
<ul class="last simple">
<li>Manual checks may have to be performed to see if a destination
object has been “connected”.</li>
<li>Multiple destination objects are usually not a possibility.</li>
<li>Callback loops can cause issues with non-reentrant code.</li>
</ul>
</dd>
<dt>Shared Memory</dt>
<dd><p class="first">The use of shared memory is a simple, commonly-used, and very
efficient method of passing data between software components.  In
this scheme, components read input data from and write data to
predetermined shared memory locations.  There are, however, several
major drawbacks to this approach:</p>
<ul class="last simple">
<li>Passing data between components using shared memory is not
thread-safe, so data transfer between components in different
threads typically requires manual, error-prone synchronization.</li>
<li>Memory usage may be high.</li>
<li>If pointers are used to specify the location of input or output
variables, manual checks may be required to make sure these
pointers have been initialized.</li>
<li>Some shared memory communication schemes use global variable
locations, which introduces a host of well-known issues.</li>
</ul>
</dd>
<dt>Message Passing</dt>
<dd><p class="first">In message-passing systems, information is transmitted by passing
data structures from one software component to another through some
sort of message delivery framework.  The messaging framework
typically employs some form of message queues to synchronize the
data transmission.  Depending on the design of the system, data may
be passed by reference or by value. Message-passing systems have a
number of benefits:</p>
<ul class="last simple">
<li>Many implementations support the transmission of messages between
threads, or even processes, without any manual synchronization.</li>
<li>Multiple messaging system implementations can be supported with no
changes to the software components.  The messaging system
implementation can be chosen at compile, link or run time.</li>
<li>The message sender does not need to know anything about the
receiver.  Zero, one, or more message receivers can be connected
to a single sender.</li>
<li>The message sender and receiver only need to agree on the format
of the data structure being passed, not the class hierarchy.</li>
<li>The amount of custom top-level glue code required to transfer data
between components is minimal.</li>
<li>The message-passing concept maps naturally to many communication
channels, such as network sockets, file I/O, serial and block
device I/O, UNIX pipes, Qt signals and slots, event-driven
systems, function calls, and message queues.</li>
<li>Many real-time operating systems offer native support for message
queues.</li>
<li>Inter-language operation is straightforward to implement.</li>
</ul>
</dd>
</dl>
<p>Although message-passing systems can be more complex and slower than
some of the alternatives, the versatility offered by this approach
makes it a great choice, given our design goals and application
domains.  For this reason, we haven chosen to use <strong>message passing as
the standard means of inter-component communication</strong> in our software.</p>
<p>The standardized messaging interface integrated into our software tool
chain is designed to be as general-purpose as possible.  This allows
each run-time environment implementation to choose a <strong>messaging
system that is tailored to the specific application domain of
interest</strong>.  For example, the run-time environment may choose to
transmit messages between components via POSIX message queues, UDP
sockets, ZeroMQ sockets, or Qt signals and slots.  Using a
standardized messaging API isolates the components from the details of
the underlying messaging system.</p>
<p>Another significant point about the design of our messaging interface
is that, unlike some messaging APIs, <strong>neither the source nor the
destination components are aware of the specific component with which
they are communicating</strong>.  The connection of message senders and
receivers occurs outside of the component, when the component is
instantiated and integrated into a higher-level component or
application in the context of a run-time environment.</p>
</div>
<div class="section" id="standardized-component-interfaces">
<h3>Standardized Component Interfaces<a class="headerlink" href="#standardized-component-interfaces" title="Permalink to this headline">¶</a></h3>
<p>In order for two components to communicate via message passing, the
message sender and receiver must agree on the content and structure of
the messages passed between them.  When designing sofware components,
developers should give careful consideration to the format of the
messages sent between components in order to make sure that components
use <strong>compatible message types</strong> when sending and receiving similar
kinds of data.  Although not strictly required, the use of
standardized message types reduces the amount of glue code required to
connect components together.  In the cases where two components with
incompatible message types must be connected, hand-coded or
auto-generated message converter components must be employed.</p>
<p>Careful thought should also be given to a component’s <em>interface</em>, or
set of input/output message names and types.  If two components share
the same interface, then these <strong>components can be interchanged</strong> at
compile time, or even run time, without changing the application
structure.  Although interface compatibility is highly desirable, it
is not absolutely critical.  Unlike many object-oriented schemes,
interfaces are not required to match in order for components to be
used together, but it does make things easier.</p>
</div>
<div class="section" id="initialization-and-reset">
<h3>Initialization and Reset<a class="headerlink" href="#initialization-and-reset" title="Permalink to this headline">¶</a></h3>
<p>Although a few software components may be truly stateless (e.g. data
converters), most components need to store some information
internally.  The way in which this internal state gets initialized (or
fails to get initialized) is significant.  Many types of bugs can be
traced to improperly initialized data members.</p>
<p>In many object-oriented systems, an object’s internal state is
initialized in the object’s constructor.  Although this is a robust
way to ensure that the data gets initialized, there are at least two
potential issues with this approach:</p>
<ol class="arabic simple">
<li>The data required for initialization may not be available at
construction time.</li>
<li>There is no clean way to <em>reset</em> a component’s internal state.</li>
</ol>
<p>Sometimes the first concern is addressed by deferring the
initialization of some internal variables until the required data is
available, but this process is error-prone.  There is usually no good
way to keep track of which variables are initialized in the
constructor, and which are initialized later.  Because of this, we
require that <strong>components initialize all of their internal variables
to known values in one place</strong>.  Even if the data required for proper
initialization of a member is not available, it must be set to <em>some
known value</em> (null or otherwise) so that the component’s operation is
at least deterministic.</p>
<p>The reset issue is a difficult one to solve, and it may be impossible
to come up with a foolproof way to handle this.  Nonetheless, the
ability to reset a component to a known initial state is very
desirable in many applications, so we desire to support it.  In order
to provide this functionality, our tools require that <strong>components
initialize their internal state in a reset message handler</strong> instead
of a constructor.  This allows application executives to reset the
component’s state as required.</p>
</div>
<div class="section" id="configuration">
<h3>Configuration<a class="headerlink" href="#configuration" title="Permalink to this headline">¶</a></h3>
<p>Since all but the simplest of software components require some type of
configuration, our tools provide built-in support for this operation.
In our system, software components are merely responsible for
declaring the names, types, and default values of their configurable
properties.  The actual <strong>assignment of these properties is handled by
the run-time environment or application executive</strong>.  This approach
allows all of the software components in an application to be
configured in a uniform way, and the configuration code can be
leveraged across many applications.</p>
<p>Because message-passing was chosen as the standardized means of
inter-component communication, it follows that components should be
configured by sending them messages.  Under the hood, a configuration
property is simply a member variable whose value can be set via an
input message.  Typically, components also send an output message when
the value of a property changes so that the value of one property can
by tied to the value of another.</p>
<p>In our system, components delegate the configuration process to the
outside world, so configuration may be handled in various ways,
depending on the application.  For embedded applications with no user
interface or filesystem, configuration may be reduced to simply
specifying property values at compile-time.  This can be done by
instantiating derived components that override default property values
or by making connections that tie the value of one property to
another.  In other applications, software components may be configured
through the use of command-line options, input files, or a GUI dialog
box.  Since component properties are all defined in a uniform way, the
code that handles the configuration does not need to be hand-coded for
each application.</p>
<p>So far, we have only considered the simple assignment of properties.
In addition to the fundamental property attributes (i.e. name, type,
default value), components can also declare additional property
attributes to supply information that may be useful in certain
run-time environments.  The declaration of min/max value constraints
could be used to automatically check that run-time property
assignments are within the expected range.  Unit constraints could be
used to check that the user has supplied values with the proper units,
or even perform automatic conversions.  Statistical constraints, like
random distribution parameters, could be used by a simulation engine
to make Monte Carlo draws.  The possibilities are endless.</p>
</div>
<div class="section" id="logging-and-screen-output">
<h3>Logging and Screen Output<a class="headerlink" href="#logging-and-screen-output" title="Permalink to this headline">¶</a></h3>
<p>Most software components require some mechanism for conveying run-time
status information to the user.  This includes things like
informational and debug messages as well as the logging of events,
errors, and warnings.  Since the way these functions are handled
varies widely from one application domain to another, the run-time
environment provides a <strong>standardized programming interface for these
functions</strong>.</p>
<p>In some domains, direct screen and log file output is available.  In
other systems, screen and log file output are available, but must be
buffered due to real-time constraints.  In some embedded domains,
reporting may be very restricted (e.g. a few words of information in a
telemetry stream), so output is reduced to capturing error codes or
source file and line numbers.  The programming interface provided by
the run-time environment must take all of these cases into
consideration.</p>
<p>The amount of information reported by an application may also change
due to compile-time options or run-time selection.  For example, users
may choose to enable verbose or debug screen output, or record errors
and warnings in a log file.  To provide the most flexibility,
<strong>logging output levels are selectable at the component level</strong>.  This
enables debug output to be enabled for one component without enabling
debug output for all components, which would be overwhelming and
counter-productive.</p>
</div>
<div class="section" id="timekeeping">
<h3>Timekeeping<a class="headerlink" href="#timekeeping" title="Permalink to this headline">¶</a></h3>
<p>Many components require some information about the passage of time in
order to operate.  This might be determining the absolute time that an
event occurred, measuring the elapsed time between events, or
scheduling some processing to occur at a specific time or periodic
frequency.  In order to support this functionality, the run-time
environment provides software components with a <strong>standardized
timekeeping API</strong> that is consistent across all application domains
and operates in the following timekeeping contexts:</p>
<dl class="docutils">
<dt>Real-Time</dt>
<dd>In systems that must meeting timing deadlines, the run-time
environment may deliver very precise time measurement and scheduling
functionality.</dd>
<dt>Non-Real-Time</dt>
<dd>In systems where timing requirements are not as demanding, the
run-time environment may supply a less precise implementation.</dd>
<dt>Simulated-Time</dt>
<dd>In some simulations, a software component’s notion of time may not
be tied to the passage of time in the real world at all, but is
instead advanced by an external simulation executive.</dd>
</dl>
<p>In some systems, there may not be a single authoritative time standard
that is suitable for all purposes.  For instance, some events may be
measured in terms of system time, and others with respect to an
external timing source.  To support these use cases, the timekeeping
API also provides support for the measurement of time according to
<strong>multiple time references</strong> that may drift relative to one another,
and for converting time values from one time base to another.</p>
</div>
<div class="section" id="scheduling">
<h3>Scheduling<a class="headerlink" href="#scheduling" title="Permalink to this headline">¶</a></h3>
<p>In general terms, scheduling is a mechanism for software components to
request that a particular section of code be executed by a processor
on the host system.  From a software component’s point of view,
scheduling can be either explicit or implicit.  The run-time
environments support several types of explicit scheduling:</p>
<dl class="docutils">
<dt>One-Shot Event</dt>
<dd>A component requests that a code segment be executed at a particular
point in time according to a specific time reference.  The time of
execution may be specified as an absolute time or as a relative time
(i.e. a delay).</dd>
<dt>Periodic Event</dt>
<dd>This is similar to a one-shot event, except that after execution of
the code segment is complete, the event is automatically
re-scheduled to execute again after a fixed amount of time.  The
time between events may be specified in terms of a period or
frequency.</dd>
<dt>Deferred Execution</dt>
<dd>Sometimes it is useful for a component to request that a code
segment be executed at some unspecified time in the future.  This is
a way for components to voluntarily yield the processor to other
components (cooperative multitasking).</dd>
</dl>
<p>In message-passing systems, implicit scheduling occurs when a
component sends out a message.  The sending of a message causes the
run-time environment to implicitly schedule one-time events for the
message handling code in each of the receiving components.</p>
<p>In multitasking systems, scheduling also involves arbitration.  If
more than one event is scheduled to run at the same time, then some
mechanism must be used to determine which one gets to execute.  This
is usually handled by setting <em>scheduling policies</em> and <em>priorities</em>
for components or for specific events.  Since arbitration involves
multiple components, this aspect of scheduling must be specified when
components are instantiated and combined into a higher-level component
or application in the context of a run-time environment, and not
within individual low-level components.</p>
</div>
<div class="section" id="blocking-vs-non-blocking-operations">
<h3>Blocking vs. Non-Blocking Operations<a class="headerlink" href="#blocking-vs-non-blocking-operations" title="Permalink to this headline">¶</a></h3>
<p>In computer programming, a task is considered to be <em>blocked</em> if it is
waiting for some condition to occur before continuing execution.  The
condition may be a resource becoming available, or the completion of a
data transfer.  A blocking operation is function call that may block
the calling task if some condition is not met (e.g. no input data is
available from a device).  Conversely, a non-blocking operation is one
that will not block the caller, even if the operation cannot be
completed.  Non-blocking calls typically return an error code to
indicate the condition that could not be satisfied.</p>
<p>Blocking operations are often desirable if a program is performing a
single sequential task, such as reading data from an input file,
processing it, and then saving the results to an output file.  When
multiple tasks must operate concurrently in the same thread of
execution, however, blocking operations become a liability.  For
example, the use of blocking network socket operations in a
single-threaded web browser could cause the whole application to
become non-responsive to user input if a web site was slow to respond.
This type of problem is typically solved by running the blocking task
in a separate thread, or by switching to non-blocking calls.</p>
<p>Since we desire to build software components that can be used in a
wide variety of contexts (e.g. single-threaded GUIs, multi-threaded
real-time systems), the <strong>use of blocking operations inside components
is highly discouraged</strong>.  In order to make up for this limitation, the
run-time environment provides a mechanism that allows components to
<strong>schedule code to be executed when a resource becomes available</strong>.</p>
</div>
<div class="section" id="file-i-o">
<h3>File I/O<a class="headerlink" href="#file-i-o" title="Permalink to this headline">¶</a></h3>
<p>Many software components need to perform file input or output
operations.  In the vast majority of cases, file I/O is performed
using system calls that may potentially block the calling task.  For
most applications, the delays associated with the reading and writing
to the file system are inconsequential, but this can be a significant
issue for some real-time systems.  This issue could be resolved by
restricting components to using only non-blocking file I/O functions,
but the plain fact of the matter is that, in most cases, this approach
is just really inconvenient.</p>
<p>In order to address these real-time concerns, we require software
components to <strong>use an API provided by the operating system
abstraction layer when performing file I/O</strong> instead of directly
accessing files through the standard API provided by the operating
system.  This approach allows the real-time operating system
abstraction layer implementations to buffer file I/O in appropriate
manner (e.g. pass output data to a separate non-real-time thread that
accesses the file system) or call the standard operating system file
I/O functions if this is not a problem in the specific application
domain.</p>
</div>
<div class="section" id="data-recording-and-playback">
<h3>Data Recording and Playback<a class="headerlink" href="#data-recording-and-playback" title="Permalink to this headline">¶</a></h3>
<p>In many applications, there is a need to record output data from
software components to a file for later analysis or debugging
purposes.  It is also helpful to be able to “play back” previously
recorded (or “canned”) data into components for further processing.
In order to provide these generally-useful capabilities, our tool set
delivers a standard set of components for message stream recording and
playback in raw and structured data file formats.</p>
</div>
<div class="section" id="top-level-application-code">
<h3>Top-Level Application Code<a class="headerlink" href="#top-level-application-code" title="Permalink to this headline">¶</a></h3>
<p>There is typically quite a bit of “top-level” code in an application
that is not reusable (except, perhaps, in a copy-and-paste fashion).
In our view, this is a shame because we would rather see developers
devote their time and put their energy into writing and debugging code
that will be used over and over again.  In order to address this
issue, we must first consider what this top-level code is doing.</p>
<p>In a typical application, the main program (or other top-level code)
performs a series of tasks that looks something like this:</p>
<ul class="simple">
<li>Process input data from the operating environment (e.g. command-line
options)</li>
<li>Allocate resources and instantiate top-level components</li>
<li>Reset components to a known state</li>
<li>Read in configuration data</li>
<li>Configure components as specified</li>
<li>Initialize components</li>
<li>Perform processing operations, which usually amounts to one of these
steps:<ul>
<li>Perform a single sequence of processing operations</li>
<li>Repeat a sequence of processing operations over and over again</li>
<li>Dispatch conditional processing operations using a state machine</li>
</ul>
</li>
<li>Wait for program termination</li>
<li>Clean up resources</li>
</ul>
<p>Since this process is very similar from application to application,
our approach is to factor the top-level code into two pieces:</p>
<ul class="simple">
<li>An application-specific <strong>top-level software component</strong> with a
standardized interface</li>
<li>A reusable <strong>application executive</strong> that sequences the top-level
component through a set of standardized <em>phases</em> corresponding to
the steps mentioned above</li>
</ul>
<p>Different application domains may still require slightly different
application executives, but this is much better than writing unique
code for every application.</p>
<p>Of course, there are often cases where software components need to be
integrated into a 3rd-party application or framework.  To support
these use cases, our tools can generate <strong>object-oriented wrappers</strong>
for any component.  If necessary, these wrappers can be tailored for
specific contexts via specialized back-end code generators.</p>
<p>Finally, there is often a desire to interact with software components
from a high-level <strong>scripting environment</strong>, so our tool set provides
this functionality as well.  This capability has many uses, including
procedural scripting, incorporating graphical user interfaces, and
dynamically defining an application structure at run-time.</p>
</div>
<div class="section" id="automatic-code-generation">
<h3>Automatic Code Generation<a class="headerlink" href="#automatic-code-generation" title="Permalink to this headline">¶</a></h3>
<p>Many developers have strong views on automatic code generation, either
positive or negative.  Our position on this subject is practical.
Although automatic code generation has been abused in many instances,
it makes sense to consider using it for the following purposes:</p>
<ul class="simple">
<li>To generate boilerplate or glue code that is tedious or error-prone
to write by hand.</li>
<li>To implement domain-specific languages that allow the program to be
written in a more concise and effective manner.</li>
<li>To allow aspects of the program to be described in a graphical
manner.</li>
<li>To reduce the duplication of information (i.e. <a class="reference internal" href="#design-principles"><span class="std std-ref">Don’t repeat
yourself</span></a>).</li>
</ul>
<p>This last point may require a little more explanation.  There are many
situations where automatic code generation could be used to help avoid
the duplication of information:</p>
<ul class="simple">
<li>The same information must be included in code and documentation.</li>
<li>The same information must be used in multiple programming languages.</li>
<li>The programming language itself requires the duplication of information.</li>
<li>The programming language source format does not allow additional
documentation or metadata to be easily incorporated.</li>
</ul>
<p>Our code crafting tools <strong>employ automatic code generation</strong> to
address many of these concerns because we believe the benefits
outweigh the drawbacks introduced by the additional complexity.
Automatic code generation is utilized in the following areas:</p>
<ul class="simple">
<li>Data type classes (e.g. message types)</li>
<li>Component interface base classes</li>
<li>Structural component implementations</li>
<li>Main programs</li>
</ul>
<p>Much care, however, is taken to make a <strong>strong separation between
auto-generated and hand-generated code</strong>.  If you still have
reservations about the utility of automatic code generation at this
point, please realize that all code is automatically-generated in some
sense.  That is the primary job of compilers and interpreters.  Our
code crafting tools simply take this a step further by using automatic
code generation to build higher-level domain-specific languages that
are better suited to our needs, not to take control away from the
programmer.  We strive to provide ways to allow the programmer to
customize generated code and do things manually when it is beneficial
to do so.</p>
</div>
<div class="section" id="file-formats">
<h3>File Formats<a class="headerlink" href="#file-formats" title="Permalink to this headline">¶</a></h3>
<p>The format of data files is another topic that deserves thoughtful
consideration.  In order to consolidate information and avoid
<a class="reference internal" href="#design-principles"><span class="std std-ref">repeating ourselves</span></a>, the file formats used
by our tools to store component interface, hierarchic structure,
message description, and configuration information <strong>allow arbitrary
metadata to be incorporated</strong> as the need arises.  This means that all
the information required to generate documentation, graphical
representations, various types of code, and other artifacts can be
found in a single location.  This is much more powerful than
alternative approaches that attempt to incorporate all of the
additional information into specialized source-code comments.</p>
<p>Our file formats also provide a mechanism for the <strong>parameterization</strong>
of entities such as message types, component interfaces, and component
implementations.  This is a powerful feature that can be leveraged to
make a code base much more manageable.</p>
<p>All of our custom text-based file formats are designed to be very
similar to one another in order to share as much code as possible
between the various processing tools.  This also eases the mental
burden on the programmer.  The use of <strong>human-readable plain-text
formats</strong> allows these files to be managed effectively using standard
source code management tools and makes life easier for software
developers.  The file formats are well-defined and designed to be easy
to process using 3rd-party tools.</p>
<p>Please note that in this section we have been discussing the file
formats used to store things like component descriptions, message
definitions, and configuration data.  The storage and formatting of
high-volume run-time input/output data is another matter entirely, and
many other factors apply.</p>
</div>
<div class="section" id="graphical-design-tools">
<h3>Graphical Design Tools<a class="headerlink" href="#graphical-design-tools" title="Permalink to this headline">¶</a></h3>
<p>The Code Craftsmen believe that some aspects of a program are best
described graphically and some aspects are more naturally expressed in
textual form.  In light of this, we desire to <strong>support both visual
and text-based workflows</strong>.</p>
<p>Our primary focus in the area of graphical design tools is to provide
a <strong>block diagram editor</strong> that allows hierarchic components and
top-level applications to be designed by drawing block diagrams
describing the input/output message connections between software
components.  This workflow not only simplifies the design process, but
also provides valuable documentation that helps developers visualize
the flow of information in the program.  In addition to a block
diagram editor, we also aim to provide other supporting tools that
allow developers to design component interfaces and message types
using a graphical interface.</p>
<p>Although graphical tools can be very helpful, we also believe that the
use of these tools should not be an essential part of a software
development workflow.  At the lowest level, <strong>all aspects of a
software application should be described using human-readable,
text-based file formats</strong> that can be hand-coded, manipulated by
3rd-party tools, or manually inspected, if necessary.  The graphical
tools simply provide an alternative means of constructing or
manipulating the underlying text files.</p>
</div>
<div class="section" id="software-stack-for-application-development">
<h3>Software Stack for Application Development<a class="headerlink" href="#software-stack-for-application-development" title="Permalink to this headline">¶</a></h3>
<p>In order to make our code crafting tools as useful as possible, they
have been designed to work in conjunction with other open-source
software to form a software stack.  Each layer of software builds on
lower-level resources to provide additional functionality.  The
following diagram offers a bird’s-eye view of our software stack for
application development.</p>
<div class="figure" id="id3">
<img alt="_images/conceptual_devel_sw_stack.svg" src="_images/conceptual_devel_sw_stack.svg" /><p class="caption"><span class="caption-text">Software Stack for Application Development (Conceptual)</span></p>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="software.html" class="btn btn-neutral float-right" title="Software" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="philosophy.html" class="btn btn-neutral" title="Philosophy" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, 2019, 2020 Jeffrey A. Webb

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    

  

  <script type="text/javascript" src="_static/js/theme.js"></script>

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>  

  <style>
    /* Sidebar */
    .wy-nav-side {
      /*width:0px;*/
    }
    .wy-side-scroll {
      /*width:0px;*/
    }
    .wy-breadcrumbs {
      visibility: hidden;
    }
    /*
    [role=search] {
    visibility: hidden;
    }
    [role=navigation] {
    visibility: hidden;
    }
    */
    h1 {
    font-size:400%;
    }
  </style>


</body>
</html>